{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n\n//Function Prototypes\nvoid bettingSystem(int *playerInfo, int &betToMatch, int numOfPlayers);\nvoid trashPile();\nint countPlayers();\nvoid configureAllSensors();\nvoid rotateToAngle(double angle);\nvoid dispenseCard(int numOfCards);\nvoid dealInitialPlayerCards(int numPlayers);\n\n//Main Game code\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  /*Initializing functions*/\n  configureAllSensors();\n  Brain.Screen.print(\"Program Started\");\n\n  /*Variables*/\n  int BetToMatch = 0;\n  int numberOfPlayers = countPlayers();\n  int playerInfo[numberOfPlayers];\n\n  for(int i = 0; i<numberOfPlayers;i++){\n    playerInfo[i] = 0;\n  }\n\n  /*Running the game*/\n  //numberOfPlayers = countPlayers();\n  trashPile();\n  dealInitialPlayerCards(numberOfPlayers);\n  bettingSystem(playerInfo, BetToMatch, numberOfPlayers);\n  \n  rotateToAngle(0.0);\n  dispenseCard(3);\n  trashPile();\n\n  bettingSystem(playerInfo, BetToMatch, numberOfPlayers);\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1,1);\n\n  rotateToAngle(0.0);\n  dispenseCard(1);\n  trashPile();\n\n  bettingSystem(playerInfo, BetToMatch, numberOfPlayers);\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1,1);\n\n  rotateToAngle(0.0);\n  dispenseCard(1);\n\n  bettingSystem(playerInfo, BetToMatch, numberOfPlayers);\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1,1);\n\n\n  MotorEject.stop(brake);\n  FlyWheelL.stop(brake);\n  FlyWheelR.stop(brake);\n\n  while(!TouchLED4.pressing());\n  \n  Brain.programStop();\n}\n//Configure all sensors to default values\nvoid configureAllSensors(){\n  BrainInertial.calibrate();\n  wait(2,seconds);\n  BrainInertial.setHeading(0,degrees);\n  BrainInertial.setRotation(0,degrees);\n  MotorEject.setPosition(0,turns);\n  FlyWheelL.setPosition(0,turns);\n  FlyWheelR.setPosition(0,turns);\n  RotationMotor.setPosition(0,turns);\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFont(mono15);\n  Optical3.setLight(ledState::on);\n}\n\n//Rotates to specified angle within (-180, 180)\nvoid rotateToAngle(double angle){\n\n  RotationMotor.setVelocity(10, percent);\n\n  //If angle is greater than the current position, spin reverse until the angle is reached\n  if(RotationMotor.position(degrees)>angle){\n    RotationMotor.spin(reverse);\n    while(RotationMotor.position(degrees)>angle){}\n\n  }\n  //If angle is less than the current position, spin forwards until the angle is reached\n  else if(RotationMotor.position(degrees)<angle){\n    RotationMotor.spin(forward);\n    while(RotationMotor.position(degrees)<angle){}\n  }\n  RotationMotor.stop(brake);\n}\n\n//dispenses a number of cards\nvoid dispenseCard(int numOfCards){\n\n  //Set motor velocities\n  MotorEject.setVelocity(20, percent);\n  FlyWheelL.setVelocity(100, percent);\n  FlyWheelR.setVelocity(100, percent);\n\n  //Start fly wheels \n  FlyWheelL.spin(forward);\n  FlyWheelR.spin(forward);\n\n  //Runs for loop once for each card\n  for(int i = 0; i<numOfCards; i++){\n\n    //Start the feeder motor\n    MotorEject.spin(forward);\n\n    //Waits until the card is seen and dispensed\n    while(DistanceSensor.objectDistance(mm)>80){}\n    while(DistanceSensor.objectDistance(mm)<80){}\n\n    MotorEject.stop();\n  }\n\n  //Runs the feeder motor backwards to reset a possible overhanging card\n  MotorEject.spin(reverse);\n  wait(0.25, seconds);\n\n  //Stops all motors\n  MotorEject.stop(brake);\n  FlyWheelL.stop(brake);\n  FlyWheelR.stop(brake);\n}\n\n//Initial Card Dealing\nvoid dealInitialPlayerCards(int numPlayers){\n  FlyWheelL.spin(forward,100,percent);\n  FlyWheelR.spin(forward,100,percent);\n\n  for(int cardsSent = 0; cardsSent < numPlayers; cardsSent++){\n\n    double rotatePerPlayer = 270.0 / numPlayers;\n    double targetAngle = (rotatePerPlayer * (cardsSent + 1))-135;\n\n    rotateToAngle(targetAngle);\n    dispenseCard(2);\n    \n  }\n\n  MotorEject.stop();\n  FlyWheelL.stop();\n  FlyWheelR.stop();\n}\n\n//Asking Players for input\nint askForInput(int playerNum, int numberOfPlayers)\n{\n  //Rotates to the angle of the player\n  rotateToAngle((-135) + (270/numberOfPlayers)*playerNum);\n\n  //Waits until something is placed near the object\n  while(!Optical3.isNearObject()){}\n\n  //Waits until a recognized color is detected and outputs the color code\n  bool running = true;\n  while(running){\n    \n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(convertColorToString(Optical3.color()));\n    color output = Optical3.color();\n    \n    if(output == red){\n      running = false;\n      return 0;\n    }else if(output == green){\n      running = false;\n      return 1;\n    }else if(output == blue){\n      running = false;\n      \n      return 2;\n    }\n  }\n  return -1;\n}\n\n//RAISE IS RED and 0\n//CHECK/MATCH IS BLUE and 2\n//FOLD IS GREEN and 1\n//Main Betting System\nvoid bettingSystem(int *playerInfo, int &betToMatch, int numOfPlayers)\n{\n  bool running = true;\n\n  while(running)\n  {\n\n    //Run for each player\n    for(int i = 0; i<numOfPlayers ; i++)\n    {\n      //make sure the player has not folded yet\n      if(playerInfo[i] != -1)\n      {\n        //If the player's bet matches the needed bet\n        if(playerInfo[i] == betToMatch){\n          switch(askForInput(i, numOfPlayers))\n          {\n            //If the person raises add 10 to pot\n            case 0:\n              betToMatch = betToMatch + 10;\n              playerInfo[i] = betToMatch;\n              break;\n              \n          }\n        }\n        //If the player is below the needed bet\n        else\n        {\n          switch(askForInput(i, numOfPlayers))\n          {\n            //If they fold set their info to -1\n            case 1:\n              playerInfo[i] = -1;\n              break;\n            //Case if they match\n            case 2:\n              playerInfo[i] = betToMatch;\n              break;\n            //Case if they raise\n            case 0:\n              betToMatch = betToMatch + 10;\n              playerInfo[i] = betToMatch;\n              break;  \n          }\n        }   \n      }\n    }\n    \n    //Used to make sure that all players are ready for the next round\n    int holder = 0;\n    //Make sure that all players are good to continue\n    for(int i = 0; i<numOfPlayers; i++)\n    {\n      //if player bet is not equal to the bet\n      if(playerInfo[i]==betToMatch || playerInfo[i] == -1)\n      {\n        holder ++;\n      }\n    }\n    if(holder == numOfPlayers){\n      running = false;\n    }\n\n    for(int i =0; i<numOfPlayers; i++){\n      Brain.Screen.print(\"player %d : %d\", i+1, playerInfo[i]);\n      Brain.Screen.newLine();\n    }\n  }\n}\n\n//Dispense random number of cards to trash pile\nvoid trashPile(){\n  srand(time(0));\n  int randomNum = rand() % 5 + 1;\n\n  double originalAngle = RotationMotor.position(degrees);\n  RotationMotor.spin(forward,10,percent);\n  while(RotationMotor.position(degrees)<180){}\n  RotationMotor.stop(brake);\n\n  dispenseCard(randomNum);\n\n  RotationMotor.spin(reverse,10,percent);\n  while(RotationMotor.position(degrees)>originalAngle){}\n  RotationMotor.stop(brake);\n  \n}\n\n//Inital player count\nint countPlayers(){\n  int playerCount = 0;\n  while(!TouchLED4.pressing() && playerCount < 7) {\n\n      if(Bumper12.pressing()) {\n          playerCount++;  \n          wait(200, msec); \n          while(Bumper12.pressing()) {\n              wait(20, msec);\n          }\n      }\n      wait(20, msec);\n  }\n  return playerCount;\n}\n","textLanguage":"cpp","robotConfig":[],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}